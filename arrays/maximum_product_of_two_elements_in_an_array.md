Стоит несколько раз уточнить характеристики входных параметров. Так как это очень важно.

В данном случае алгоритм находжения был написан верно, но из-за неправильной
инициализации начальных значений решение оказалось неврным.

```go
func maxProduct(nums []int) int {
	// изначальный вариант
	max1, max2 := nums[0], nums[1]

	// правильный вариант
	var max1, max2 int

	// Так как значения будут равны 1 <= nums[i] <= 10^3
	// То значит можно инициализировать 0, так как он будут точно наименьшим.
	// А вот инициализировать значениями из массива, это плохая идея, так как
	// придется учитывать такой случай [10,2,5,2].
	// В таком случае [10,2,5,2] у нас max1 = 10, а max2 = 2 и на первной же
	// итерации цикла мы получим неверное поведение, а имеено max2 = max1 = 10

	for _, v := range nums {
		if v > max1 {
			max2 = max1
			max1 = v
		} else if v > max2 {
			max2 = v
		}
	}

	return (max1-1) * (max2-1)
}
```